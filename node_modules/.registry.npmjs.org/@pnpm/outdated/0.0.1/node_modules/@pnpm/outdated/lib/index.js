"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const RegClient = require("npm-registry-client");
const pnpm_shrinkwrap_1 = require("pnpm-shrinkwrap");
const package_store_1 = require("package-store");
const npa = require("npm-package-arg");
const pnpm_logger_1 = require("pnpm-logger");
const depTypes = ['dependencies', 'devDependencies', 'optionalDependencies'];
function default_1(pkgPath, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        return _outdated([], pkgPath, opts);
    });
}
exports.default = default_1;
function forPackages(packages, pkgPath, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        return _outdated(packages, pkgPath, opts);
    });
}
exports.forPackages = forPackages;
function _outdated(forPkgs, pkgPath, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const wantedShrinkwrap = yield pnpm_shrinkwrap_1.read(pkgPath, { ignoreIncompatible: false });
        if (!wantedShrinkwrap) {
            throw new Error('No shrinkwrapfile in this directory. Run `pnpm install` to generate one.');
        }
        const storePath = yield package_store_1.resolveStore(opts.store, pkgPath);
        const currentShrinkwrap = (yield pnpm_shrinkwrap_1.readPrivate(pkgPath, { ignoreIncompatible: false })) || {};
        const client = new RegClient(adaptConfig(opts));
        const got = package_store_1.createGot(client, {
            networkConcurrency: opts.networkConcurrency,
            rawNpmConfig: opts.rawNpmConfig,
            alwaysAuth: opts.alwaysAuth,
            registry: wantedShrinkwrap.registry,
            retries: opts.fetchRetries,
            factor: opts.fetchRetryFactor,
            maxTimeout: opts.fetchRetryMaxtimeout,
            minTimeout: opts.fetchRetryMintimeout,
        });
        const metaCache = new Map();
        const outdated = [];
        yield Promise.all(depTypes.map((depType) => __awaiter(this, void 0, void 0, function* () {
            if (!wantedShrinkwrap[depType])
                return;
            let pkgs = Object.keys(wantedShrinkwrap[depType]);
            if (forPkgs.length) {
                pkgs = pkgs.filter(pkgName => forPkgs.indexOf(pkgName) !== -1);
            }
            yield Promise.all(pkgs.map((packageName) => __awaiter(this, void 0, void 0, function* () {
                const resolution = yield package_store_1.resolve(npa.resolve(packageName, 'latest'), {
                    downloadPriority: 0,
                    got,
                    registry: wantedShrinkwrap.registry,
                    metaCache,
                    offline: opts.offline,
                    prefix: pkgPath,
                    loggedPkg: {
                        rawSpec: `${packageName}@latest`,
                        name: packageName,
                    },
                    storePath,
                });
                if (!resolution || !resolution.package)
                    return;
                const latest = resolution.package.version;
                if (!currentShrinkwrap[depType][packageName]) {
                    outdated.push({
                        packageName,
                        wanted: wantedShrinkwrap[depType][packageName],
                        latest,
                    });
                    return;
                }
                if (currentShrinkwrap[depType][packageName] !== wantedShrinkwrap[depType][packageName] ||
                    latest !== currentShrinkwrap[depType][packageName]) {
                    outdated.push({
                        packageName,
                        current: currentShrinkwrap[depType][packageName],
                        wanted: wantedShrinkwrap[depType][packageName],
                        latest,
                    });
                }
            })));
        })));
        return outdated.sort((pkg1, pkg2) => pkg1.packageName.localeCompare(pkg2.packageName));
    });
}
function adaptConfig(opts) {
    const registryLog = pnpm_logger_1.default('registry');
    return {
        proxy: {
            http: opts.proxy,
            https: opts.httpsProxy,
            localAddress: opts.localAddress
        },
        ssl: {
            certificate: opts.cert,
            key: opts.key,
            ca: opts.ca,
            strict: opts.strictSsl
        },
        retry: {
            count: opts.fetchRetries,
            factor: opts.fetchRetryFactor,
            minTimeout: opts.fetchRetryMintimeout,
            maxTimeout: opts.fetchRetryMaxtimeout
        },
        userAgent: opts.userAgent,
        log: Object.assign({}, registryLog, {
            verbose: registryLog.debug.bind(null, 'http'),
            http: registryLog.debug.bind(null, 'http'),
        }),
        defaultTag: opts.tag
    };
}
//# sourceMappingURL=index.js.map