"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const findUp = require("find-up");
const fs = require("mz/fs");
const runScript_1 = require("../runScript");
const readPkg_1 = require("../fs/readPkg");
const lifecycle = require("@zkochan/npm-lifecycle");
const pnpm_logger_1 = require("pnpm-logger");
const pnpmNodeModules = findUp.sync('node_modules', { cwd: __dirname });
const nodeGyp = path.resolve(pnpmNodeModules, 'node-gyp/bin/node-gyp.js');
function noop() { }
function postInstall(root, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkg = yield readPkg_1.fromDir(root);
        const scripts = pkg && pkg.scripts || {};
        if (!scripts['install']) {
            yield checkBindingGyp(root, opts);
        }
        const modulesDir = path.join(opts.initialWD, 'node_modules');
        const scriptsOpts = {
            rawNpmConfig: opts.rawNpmConfig,
            pkgId: opts.pkgId,
            modulesDir,
            root,
        };
        yield npmRunScript('preinstall', pkg, scriptsOpts);
        yield npmRunScript('install', pkg, scriptsOpts);
        yield npmRunScript('postinstall', pkg, scriptsOpts);
        return;
    });
}
exports.default = postInstall;
function npmRunScript(stage, pkg, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!pkg.scripts || !pkg.scripts[stage])
            return;
        return lifecycle(pkg, stage, opts.root, {
            dir: opts.modulesDir,
            config: opts.rawNpmConfig,
            stdio: opts.stdio || 'pipe',
            log: {
                level: opts.stdio === 'inherit' ? undefined : 'silent',
                info: noop,
                warn: noop,
                silly: npmLog,
                verbose: npmLog,
                pause: noop,
                resume: noop,
                clearProgress: noop,
                showProgress: noop,
            },
        });
        function npmLog(prefix, logid, stdtype, line) {
            switch (stdtype) {
                case 'stdout':
                    pnpm_logger_1.lifecycleLogger.info({
                        script: stage,
                        line: line.toString(),
                        pkgId: opts.pkgId,
                    });
                    return;
                case 'stderr':
                    pnpm_logger_1.lifecycleLogger.error({
                        script: stage,
                        line: line.toString(),
                        pkgId: opts.pkgId,
                    });
                    return;
                case 'Returned: code:':
                    if (opts.stdio === 'inherit') {
                        // Preventing the pnpm reporter from overriding the project's script output
                        return;
                    }
                    const code = arguments[3];
                    pnpm_logger_1.lifecycleLogger[code === 0 ? 'info' : 'error']({
                        pkgId: opts.pkgId,
                        script: stage,
                        exitCode: code,
                    });
                    return;
            }
        }
    });
}
exports.npmRunScript = npmRunScript;
/**
 * Run node-gyp when binding.gyp is available. Only do this when there's no
 * `install` script (see `npm help scripts`).
 */
function checkBindingGyp(root, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.stat(path.join(root, 'binding.gyp'));
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return;
            }
        }
        return runScript_1.default(nodeGyp, ['rebuild'], {
            cwd: root,
            pkgId: opts.pkgId,
            userAgent: opts.userAgent,
        });
    });
}
//# sourceMappingURL=postInstall.js.map